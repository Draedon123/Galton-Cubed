(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const o of n)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function t(n){const o={};return n.integrity&&(o.integrity=n.integrity),n.referrerPolicy&&(o.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?o.credentials="include":n.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(n){if(n.ep)return;n.ep=!0;const o=t(n);fetch(n.href,o)}})();class G{samples;maxSamples;constructor(e){this.samples=[],this.maxSamples=e}get average(){return this.samples.reduce((e,t)=>e+t,0)/this.samples.length}addSample(e){this.samples.length===this.maxSamples&&this.samples.shift(),this.samples.push(e)}reset(){this.samples.splice(0,this.samples.length)}}class M{static modifiedDevices=new Set;canTimestamp;querySet;resolveBuffer;resultBuffer;rollingAverage;onUpdate;constructor(e,t=()=>{}){if(this.canTimestamp=e.features.has("timestamp-query"),this.onUpdate=t,this.rollingAverage=new G(50),this.canTimestamp&&(this.querySet=e.createQuerySet({label:"GPUTimer Query Set",type:"timestamp",count:2}),this.resolveBuffer=e.createBuffer({label:"GPUTimer Resolve Buffer",size:this.querySet.count*BigInt64Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.resultBuffer=e.createBuffer({label:"GPUTimer Result Buffer",size:this.resolveBuffer.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})),!M.modifiedDevices.has(e)){const s=e.queue.submit.bind(e.queue);e.queue.submit=n=>{s(n),!(!this.canTimestamp||this.resultBuffer.mapState!=="unmapped")&&this.resultBuffer.mapAsync(GPUMapMode.READ).then(()=>{const o=new BigInt64Array(this.resultBuffer.getMappedRange());this.rollingAverage.addSample(Number(o[1]-o[0])),this.resultBuffer.unmap(),this.onUpdate(this.rollingAverage.average)})},M.modifiedDevices.add(e)}}get time(){return this.rollingAverage.average}beginComputePass(e,t){const s={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},n=e.beginComputePass({...t,...this.canTimestamp?{timestampWrites:s}:void 0}),o=n.end.bind(n);return n.end=()=>{o(),this.canTimestamp&&(e.resolveQuerySet(this.querySet,0,this.querySet.count,this.resolveBuffer,0),this.resultBuffer.mapState==="unmapped"&&e.copyBufferToBuffer(this.resolveBuffer,this.resultBuffer))},n}beginRenderPass(e,t){const s={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},n=e.beginRenderPass({...t,...this.canTimestamp?{timestampWrites:s}:void 0}),o=n.end.bind(n);return n.end=()=>{o(),this.canTimestamp&&(e.resolveQuerySet(this.querySet,0,this.querySet.count,this.resolveBuffer,0),this.resultBuffer.mapState==="unmapped"&&e.copyBufferToBuffer(this.resolveBuffer,this.resultBuffer))},n}reset(){this.rollingAverage.reset()}}class T{components;constructor(){this.components=new Float32Array(16),this.components[0]=1,this.components[5]=1,this.components[10]=1,this.components[15]=1}static multiplyMatrices(e,t,s=new T){const n=e.components[0],o=e.components[1],i=e.components[2],r=e.components[3],a=e.components[4],p=e.components[5],w=e.components[6],y=e.components[7],l=e.components[8],v=e.components[9],B=e.components[10],m=e.components[11],b=e.components[12],x=e.components[13],P=e.components[14],E=e.components[15];let u=t.components[0],f=t.components[1],d=t.components[2],g=t.components[3];return s.components[0]=u*n+f*a+d*l+g*b,s.components[1]=u*o+f*p+d*v+g*x,s.components[2]=u*i+f*w+d*B+g*P,s.components[3]=u*r+f*y+d*m+g*E,u=t.components[4],f=t.components[5],d=t.components[6],g=t.components[7],s.components[4]=u*n+f*a+d*l+g*b,s.components[5]=u*o+f*p+d*v+g*x,s.components[6]=u*i+f*w+d*B+g*P,s.components[7]=u*r+f*y+d*m+g*E,u=t.components[8],f=t.components[9],d=t.components[10],g=t.components[11],s.components[8]=u*n+f*a+d*l+g*b,s.components[9]=u*o+f*p+d*v+g*x,s.components[10]=u*i+f*w+d*B+g*P,s.components[11]=u*r+f*y+d*m+g*E,u=t.components[12],f=t.components[13],d=t.components[14],g=t.components[15],s.components[12]=u*n+f*a+d*l+g*b,s.components[13]=u*o+f*p+d*v+g*x,s.components[14]=u*i+f*w+d*B+g*P,s.components[15]=u*r+f*y+d*m+g*E,s}static perspective(e,t,s,n){const o=new T,i=1/Math.tan(e/2);if(o.components[0]=i/t,o.components[5]=i,o.components[11]=-1,o.components[15]=0,n!==1/0){const r=1/(s-n);o.components[10]=n*r,o.components[14]=n*s*r}else o.components[10]=-1,o.components[14]=-s;return o}static lookAt(e,t,s){const n=new T,o=1e-6;let i,r,a,p,w,y,l,v,B,m;const b=e.x,x=e.y,P=e.z,E=s.x,u=s.y,f=s.z,d=t.x,g=t.y,R=t.z;return Math.abs(b-d)<o&&Math.abs(x-g)<o&&Math.abs(P-R)<o?(console.warn("Look At too close to Position"),new T):(l=b-d,v=x-g,B=P-R,m=1/Math.sqrt(l*l+v*v+B*B),l*=m,v*=m,B*=m,i=u*B-f*v,r=f*l-E*B,a=E*v-u*l,m=Math.sqrt(i*i+r*r+a*a),m?(m=1/m,i*=m,r*=m,a*=m):(i=0,r=0,a=0),p=v*a-B*r,w=B*i-l*a,y=l*r-v*i,m=Math.sqrt(p*p+w*w+y*y),m?(m=1/m,p*=m,w*=m,y*=m):(p=0,w=0,y=0),n.components[0]=i,n.components[1]=p,n.components[2]=l,n.components[3]=0,n.components[4]=r,n.components[5]=w,n.components[6]=v,n.components[7]=0,n.components[8]=a,n.components[9]=y,n.components[10]=B,n.components[11]=0,n.components[12]=-(i*b+r*x+a*P),n.components[13]=-(p*b+w*x+y*P),n.components[14]=-(l*b+v*x+B*P),n.components[15]=1,n)}copyFrom(e){this.components[0]=e.components[0],this.components[1]=e.components[1],this.components[2]=e.components[2],this.components[3]=e.components[3],this.components[4]=e.components[4],this.components[5]=e.components[5],this.components[6]=e.components[6],this.components[7]=e.components[7],this.components[8]=e.components[8],this.components[9]=e.components[9],this.components[10]=e.components[10],this.components[11]=e.components[11],this.components[12]=e.components[12],this.components[13]=e.components[13],this.components[14]=e.components[14],this.components[15]=e.components[15]}}class F extends T{buffer;device;constructor(e,t,s=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST){super(),this.device=e,this.buffer=e.createBuffer({label:t,usage:s,size:64}),this.device=e}writeBuffer(){this.device.queue.writeBuffer(this.buffer,0,this.components.buffer)}}function q(h){return`/Galton-Cubed/${h}`}const D=Math.PI/180;function I(h){return h*D}const L=180/Math.PI;function O(h){return h*L}class c{components;constructor(e=0,t=0,s=0){this.components=new Float32Array(3),this.components[0]=e,this.components[1]=t,this.components[2]=s}static cross(e,t){const s=e.components[0],n=e.components[1],o=e.components[2],i=t.components[0],r=t.components[1],a=t.components[2];return new c(n*a-o*r,o*i-s*a,s*r-n*i)}static add(e,t){return new c(e.components[0]+t.components[0],e.components[1]+t.components[1],e.components[2]+t.components[2])}add(e){return this.components[0]+=e.components[0],this.components[1]+=e.components[1],this.components[2]+=e.components[2],this}static subtract(e,t){return new c(e.components[0]-t.components[0],e.components[1]-t.components[1],e.components[2]-t.components[2])}static scale(e,t){return new c(e.components[0]*t,e.components[1]*t,e.components[2]*t)}scale(e){return this.components[0]*=e,this.components[1]*=e,this.components[2]*=e,this}normalise(){const e=this.magnitude;if(e<1e-8)return console.error("Magnitude of vector too close to 0 to normalise"),this;const t=1/e;return this.components[0]*=t,this.components[1]*=t,this.components[2]*=t,this}get magnitude(){return Math.hypot(this.components[0],this.components[1],this.components[2])}get x(){return this.components[0]}get y(){return this.components[1]}get z(){return this.components[2]}set x(e){this.components[0]=e}set y(e){this.components[1]=e}set z(e){this.components[2]=e}}class z{position;lookAt;aspectRatio;near;far;fovRadians;constructor(e={}){this.position=e.position??new c,this.lookAt=e.lookAt??new c(0,0,-1),this.aspectRatio=e.aspectRatio??16/9,this.near=e.near??.1,this.far=e.far??1e3,this.fovRadians=I(e.fovDegrees??60)}get fovDegrees(){return O(this.fovRadians)}set fovDegrees(e){this.fovRadians=I(e)}getPerspectiveMatrix(){return T.perspective(this.fovRadians,this.aspectRatio,this.near,this.far)}getViewMatrix(){const e=c.subtract(this.lookAt,this.position).normalise(),t=new c(0,1,0);return T.lookAt(this.position,c.add(this.position,e),t)}getPerspectiveViewMatrix(){return T.multiplyMatrices(this.getPerspectiveMatrix(),this.getViewMatrix())}}class V{vertexBuffer;indexBuffer;vertices;indices;rawVertices;rawIndices;label;constructor(e,t,s=""){this.rawVertices=e,this.rawIndices=t??null,this.label=s}initialise(e){this.vertices=new Float32Array(this.rawVertices.map(t=>[t.position.x,t.position.y,t.position.z,t.normal.x,t.normal.y,t.normal.z]).flat()),this.rawIndices?(this.indices=new(this.indexFormat==="uint16"?Uint16Array:Uint32Array)(this.rawIndices),this.indexBuffer=e.createBuffer({label:`${this.label} Index Buffer`,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,size:this.indices.byteLength}),e.queue.writeBuffer(this.indexBuffer,0,this.indices.buffer)):(this.indices=null,this.indexBuffer=null),this.vertexBuffer=e.createBuffer({label:`${this.label} Vertex Buffer`,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,size:this.vertices.byteLength}),e.queue.writeBuffer(this.vertexBuffer,0,this.vertices.buffer)}render(e){e.setVertexBuffer(0,this.vertexBuffer),this.indexBuffer!==null?(e.setIndexBuffer(this.indexBuffer,this.indexFormat),e.drawIndexed(this.indexCount)):e.draw(this.vertices.length/3)}get verticeCount(){return this.vertices.length/3}get indexCount(){return this.indices?.length??0}get indexFormat(){return this.vertices.length>65535?"uint32":"uint16"}}class A extends V{constructor(e,t){const s=[],n=[],o=[new c(1,0,0),new c(-1,0,0),new c(0,1,0),new c(0,-1,0),new c(0,0,1),new c(0,0,-1)];for(let i=0;i<o.length;i++){const r=o[i],a=A.createCubeFace(r,i*e*e,e,t);s.push(...a.vertices),n.push(...a.indices)}super(s,n)}static createCubeFace(e,t,s,n){const o=[],i=[],r=new c(e.y,e.z,e.x).scale(2*n),a=c.cross(e,r),p=c.subtract(e,c.add(r,a).scale(.5)),w=c.scale(r,1/s),y=c.scale(a,1/s);for(let l=0;l<s;l++)for(let v=0;v<s;v++){const B=c.add(p,c.scale(w,l)).add(c.scale(y,v)).normalise(),m=c.scale(B,n);if(o.push({position:m,normal:B}),l!==s-1&&v!==s-1){const b=t+l+v*s;i.push(b,b+1,b+s+1,b,b+s+1,b+s)}}return{vertices:o,indices:i}}}class S{shader;constructor(e,t,s){this.shader=e.createShaderModule({label:s,code:t})}static async fetch(e,t,s,n=o=>o){const o=await(await fetch(t)).text(),i=await S.preprocess(t,o);return new S(e,n(i),s)}static async preprocess(e,t){return S.resolveImports(e,t)}static async resolveImports(e,t,s=[]){const n=/#!import.*\s/g,o=e.split("/"),i=o.slice(0,o.length-1).join("/")+"/",r=t.match(n)?.map(p=>p.replaceAll(/(#!import)|\s/g,"")).filter(p=>!s.includes(p)).map(p=>i+p+".wgsl")??[];return((await Promise.all(r.map(async p=>{const w=await fetch(p);if(!w.ok)return"";const y=await w.text();return S.resolveImports(p,y,s)}))).join("")+t).replaceAll(n,"")}}const U=new A(20,2);class C{canvas;camera;settings;device;ctx;canvasFormat;gpuTimer;initialised;renderBindGroup;renderPipeline;vertexBuffer;objectPositions;depthTexture;perspectiveViewMatrix;constructor(e,t,s){const n=e.getContext("webgpu");if(n===null)throw new Error("Could not create WebGPU Canvas Context");this.settings={timing:t.timing},this.canvas=e,this.device=s,this.ctx=n,this.canvasFormat="rgba8unorm",this.camera=new z(t.cameraOptions),this.perspectiveViewMatrix=new F(s,"Perspective View Matrix"),this.gpuTimer=new M(this.device,o=>{const i=o/1e3,r=o/1e6,a=o/1e9,p=r>1,w=(p?r:i).toFixed(2),y=p?"ms":"μs";if(this.settings.timing?.frameTimeElement!==void 0&&(this.settings.timing.frameTimeElement.textContent=w+y),this.settings.timing?.fpsElement!==void 0){const l=1/a;this.settings.timing.fpsElement.textContent=l.toFixed(2)}}),this.gpuTimer.canTimestamp||(this.settings.timing?.frameTimeElement!==void 0&&(this.settings.timing.frameTimeElement.textContent="[Not supported by browser]"),this.settings.timing?.fpsElement!==void 0&&(this.settings.timing.fpsElement.textContent="[Not supported by browser]")),this.initialised=!1}async initialise(){this.initialised||(U.initialise(this.device),await this.initialiseRendering(),new ResizeObserver(e=>{const t=e[0],s=t.devicePixelContentBoxSize[0].inlineSize,n=t.devicePixelContentBoxSize[0].blockSize;this.canvas.width=s,this.canvas.height=n,this.camera.aspectRatio=s/n,this.depthTexture?.destroy(),this.depthTexture=this.createDepthTexture(),this.gpuTimer.reset(),this.render()}).observe(this.canvas),this.initialised=!0)}createDepthTexture(){return this.device.createTexture({label:"Renderer Depth Texture",size:[this.canvas.width,this.canvas.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT})}async initialiseRendering(){this.ctx.configure({device:this.device,format:this.canvasFormat});const e=await S.fetch(this.device,q("shaders/render.wgsl"));this.depthTexture=this.createDepthTexture(),this.vertexBuffer=U.vertexBuffer,this.objectPositions=this.device.createBuffer({label:"Positions Buffer",size:24,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.device.queue.writeBuffer(this.objectPositions,0,new Float32Array([0,0,0,3,0,0]));const t=this.device.createBindGroupLayout({label:"Cube Bind Group Layout",entries:[{binding:0,buffer:{type:"uniform"},visibility:GPUShaderStage.VERTEX}]});this.renderBindGroup=this.device.createBindGroup({label:"Render Bing Group",layout:t,entries:[{binding:0,resource:{buffer:this.perspectiveViewMatrix.buffer}}]});const s=this.device.createPipelineLayout({label:"Renderer Render Pipeline Layout",bindGroupLayouts:[t]});this.renderPipeline=this.device.createRenderPipeline({label:"Renderer Render Pipeline",layout:s,vertex:{module:e.shader,buffers:[{arrayStride:24,attributes:[{shaderLocation:0,format:"float32x3",offset:0},{shaderLocation:1,format:"float32x3",offset:12}]},{arrayStride:12,stepMode:"instance",attributes:[{shaderLocation:2,format:"float32x3",offset:0}]}]},fragment:{module:e.shader,targets:[{format:this.canvasFormat}]},primitive:{cullMode:"front"},depthStencil:{format:"depth24plus",depthCompare:"less",depthWriteEnabled:!0}})}render(){this.perspectiveViewMatrix.copyFrom(this.camera.getPerspectiveViewMatrix()),this.perspectiveViewMatrix.writeBuffer(),this.renderToCanvas()}renderToCanvas(){const e=this.device.createCommandEncoder(),t=this.gpuTimer.beginRenderPass(e,{colorAttachments:[{view:this.ctx.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:this.depthTexture.createView(),depthLoadOp:"clear",depthStoreOp:"store",depthClearValue:1}});t.setVertexBuffer(0,this.vertexBuffer),t.setVertexBuffer(1,this.objectPositions),t.setBindGroup(0,this.renderBindGroup),t.setPipeline(this.renderPipeline),U.render(t),t.end(),this.device.queue.submit([e.finish()])}static async create(e,t={}){if(!("gpu"in navigator))throw new Error("WebGPU not supported");const s=await navigator.gpu.requestAdapter();if(s===null)throw new Error("Could not find suitable GPU Adapter. Maybe your browser doesn't support WebGPU?");const n=await s.requestDevice({requiredFeatures:C.requestFeatures(s,"timestamp-query")});if(n===null)throw new Error("Could not find suitable GPU Device. Maybe your browser doesn't support WebGPU?");return new C(e,t,n)}static requestFeatures(e,...t){return t.filter(s=>{const n=e.features.has(s);return n||console.warn(`GPU Feature ${s} not supported`),n})}}class k{settings;callbacks=[];frameID;lastFrameTime;totalTime;constructor(e={}){this.frameID=null,this.lastFrameTime=0,this.totalTime=0,this.callbacks=[],this.settings={wormholeThreshold:e.wormholeThreshold??500}}start(){this.running||(this.totalTime=0,this.lastFrameTime=-1,this.frameID=requestAnimationFrame(this.tick.bind(this)))}stop(){this.running&&(cancelAnimationFrame(this.frameID),this.frameID=null)}toggle(){this.running?this.stop():this.start()}addCallback(e){this.callbacks.push(e)}tick(e){this.lastFrameTime<0&&(this.lastFrameTime=e);const t=e-this.lastFrameTime,s=this.totalTime+t;if(t<this.settings.wormholeThreshold){const n={deltaTime:t,totalTime:s};for(const o of this.callbacks)o(n);this.totalTime=s}this.lastFrameTime=e,this.frameID=requestAnimationFrame(this.tick.bind(this))}get running(){return this.frameID!==null}}function N(h){W()}function W(){const h=document.getElementById("chevron"),e=document.getElementById("content");if(h===null)throw new Error("Could not find chevron element");if(e===null)throw new Error("Could not find info panel");h.addEventListener("click",()=>{h.classList.toggle("collapsed"),e.classList.toggle("collapsed")})}async function Y(){const h=document.getElementById("main"),e=document.getElementById("frameTime"),t=document.getElementById("fps"),s=await C.create(h,{timing:{frameTimeElement:e,fpsElement:t}});await s.initialise(),s.camera.position=new c(4,2.5,2.5),s.camera.fovDegrees=60,s.camera.lookAt=new c(0,0,0),N();const n=new k;n.addCallback(()=>{s.render()}),n.start(),h.addEventListener("click",()=>{h.requestPointerLock()})}Y().catch(h=>{const e=h instanceof Error?h.message:JSON.stringify(h),t=document.getElementById("message");t.classList.add("error"),t.textContent=e;const s=document.getElementById("chevron"),n=document.getElementById("content");s?.classList.add("collapsed"),n?.classList.add("collapsed"),console.trace(),console.error(e)});
